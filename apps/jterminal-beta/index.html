<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Jtermnial</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%; width: 100%;
      background: #000; color: #fff;
      font-family: monospace;
    }
    #terminal {
      display: flex; flex-direction: column;
      height: 100%; padding: 10px;
    }
    #output {
      flex: 1; overflow-y: auto;
      white-space: pre-wrap;
    }
    #input-line { display: flex; }
    #prompt { flex-shrink: 0; }
    #cmdline {
      background: transparent; border: none;
      color: inherit; flex: 1;
      outline: none; font-family: inherit;
      font-size: inherit;
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="output"></div>
    <div id="input-line">
      <span id="prompt">juser@jtermnial:~/home$ </span>
      <input type="text" id="cmdline" autofocus autocomplete="off" />
    </div>
  </div>

  <script>
    // Virtual filesystem
    const FS = {
      type: 'dir',
      children: {
        home: { type: 'dir', children: {} }
      }
    };
    let cwd = ['home'];

    const outputEl = document.getElementById('output');
    const cmdlineEl = document.getElementById('cmdline');
    const promptEl = document.getElementById('prompt');

    function print(text = '') {
      const line = document.createElement('div');
      line.textContent = text;
      outputEl.appendChild(line);
      outputEl.scrollTop = outputEl.scrollHeight;
    }

    function getNode(pathArr) {
      let node = FS;
      for (let part of pathArr) {
        if (node.type !== 'dir' || !(part in node.children)) return null;
        node = node.children[part];
      }
      return node;
    }

    function resolvePath(arg) {
      let parts = arg.startsWith('/') ? [] : [...cwd];
      for (let p of arg.split('/')) {
        if (!p || p === '.') continue;
        if (p === '..') {
          if (parts.length) parts.pop();
        } else {
          parts.push(p);
        }
      }
      return parts;
    }

    function pathString(arr) {
      return '/' + arr.join('/');
    }

    function listDir(pathArr) {
      const node = getNode(pathArr);
      return node && node.type === 'dir'
        ? Object.keys(node.children)
        : null;
    }

    async function runCommand(input) {
      if (!input.trim()) return;
      print(promptEl.textContent + input);
      const [cmd, ...args] = input.trim().split(/\s+/);

      switch (cmd) {
        case 'help':
          print(`help        - Show this message
wget URL    - Download text from URL into file
nano FILE   - Open editor to edit/create a file
cd [PATH]   - Change directory
mkdir NAME  - Create a directory
ls [PATH]   - List directory
clear       - Clear screen`);
          break;

        case 'wget':
          if (!args[0]) {
            print('wget: missing URL');
            break;
          }
          try {
            const url = args[0];
            const res = await fetch(url);
            if (!res.ok) throw new Error(res.statusText);
            const text = await res.text();
            const fname = url.split('/').pop() || 'index.txt';
            const dir = getNode(cwd);
            dir.children[fname] = { type: 'file', content: text };
            print(`Downloaded ${url} → ${fname}`);
          } catch (e) {
            print(`wget: error fetching ${args[0]}: ${e.message}`);
          }
          break;

        case 'nano':
          if (!args[0]) {
            print('nano: missing file operand');
            break;
          }
          const name = args[0];
          const dirNode = getNode(cwd);
          if (!dirNode.children[name]) {
            dirNode.children[name] = { type: 'file', content: '' };
          }
          const existing = dirNode.children[name].content;
          const newContent = prompt(`Editing ${name}:`, existing);
          if (newContent !== null) {
            dirNode.children[name].content = newContent;
            print(`Saved ${name}`);
          } else {
            print(`Cancelled ${name}`);
          }
          break;

        case 'cd': {
          const target = args[0] ? resolvePath(args[0]) : ['home'];
          if (getNode(target)?.type === 'dir') {
            cwd = target;
            promptEl.textContent = `juser@jtermnial:${pathString(cwd)}$ `;
          } else {
            print(`cd: no such directory: ${args[0]}`);
          }
          break;
        }

        case 'mkdir':
          if (!args[0]) {
            print('mkdir: missing operand');
            break;
          }
          const dd = getNode(cwd);
          if (dd.children[args[0]]) {
            print(`mkdir: cannot create directory '${args[0]}': Exists`);
          } else {
            dd.children[args[0]] = { type: 'dir', children: {} };
          }
          break;

        case 'ls': {
          const target = args[0] ? resolvePath(args[0]) : cwd;
          const list = listDir(target);
          if (list) print(list.join('  '));
          else print(`ls: cannot access '${args[0]||'.'}': No such directory`);
          break;
        }

        case 'clear':
          outputEl.innerHTML = '';
          break;

        default:
          print(`${cmd}: command not found`);
      }
    }

    cmdlineEl.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const cmd = cmdlineEl.value;
        runCommand(cmd);
        cmdlineEl.value = '';
      }
    });

    // initial message
    print('Jtermnial v1.0 — type \'help\'');
  </script>
</body>
</html>
